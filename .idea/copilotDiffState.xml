<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/msystem/walking/MainActivity.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/msystem/walking/MainActivity.java" />
              <option name="originalContent" value="package com.msystem.walking;&#10;&#10;import android.Manifest;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.location.Location;&#10;import android.os.Bundle;&#10;import android.preference.PreferenceManager;&#10;import android.view.Menu;&#10;import android.view.MenuItem;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.app.ActivityCompat;&#10;import androidx.core.content.ContextCompat;&#10;&#10;import com.google.android.gms.location.FusedLocationProviderClient;&#10;import com.google.android.gms.location.LocationCallback;&#10;import com.google.android.gms.location.LocationRequest;&#10;import com.google.android.gms.location.LocationResult;&#10;import com.google.android.gms.location.LocationServices;&#10;import com.google.android.gms.location.Priority;&#10;import com.msystem.walking.auth.LoginActivity;&#10;import com.msystem.walking.repository.AuthRepository;&#10;&#10;import org.osmdroid.api.IMapController;&#10;import org.osmdroid.config.Configuration;&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory;&#10;import org.osmdroid.util.GeoPoint;&#10;import org.osmdroid.views.MapView;&#10;import org.osmdroid.views.overlay.Marker;&#10;import org.osmdroid.views.overlay.mylocation.GpsMyLocationProvider;&#10;import org.osmdroid.views.overlay.mylocation.MyLocationNewOverlay;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;    private static final int LOCATION_PERMISSION_REQUEST_CODE = 1001;&#10;&#10;    private AuthRepository authRepository;&#10;    private MapView mapView;&#10;    private IMapController mapController;&#10;    private MyLocationNewOverlay locationOverlay;&#10;    private FusedLocationProviderClient fusedLocationClient;&#10;    private LocationCallback locationCallback;&#10;    private Marker userMarker;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;&#10;        // Configurar OSMDroid para melhor performance&#10;        Configuration.getInstance().load(this, PreferenceManager.getDefaultSharedPreferences(this));&#10;        Configuration.getInstance().setUserAgentValue(getPackageName());&#10;&#10;        setContentView(R.layout.activity_main);&#10;&#10;        authRepository = AuthRepository.getInstance();&#10;&#10;        // Verificar se o usuário está autenticado&#10;        if (authRepository.getCurrentUser() == null) {&#10;            redirectToLogin();&#10;            return;&#10;        }&#10;&#10;        initializeMap();&#10;        initializeLocationServices();&#10;        setupObservers();&#10;        setupButtonListeners();&#10;&#10;        // Verificar e solicitar permissões de localização&#10;        if (checkLocationPermissions()) {&#10;            startLocationTracking();&#10;        } else {&#10;            requestLocationPermissions();&#10;        }&#10;    }&#10;&#10;    private void initializeMap() {&#10;        mapView = findViewById(R.id.osmMapView);&#10;&#10;        // Configurar o mapa com melhor qualidade&#10;        mapView.setTileSource(TileSourceFactory.MAPNIK); // OpenStreetMap padrão&#10;        mapView.setMultiTouchControls(true);&#10;        mapView.setBuiltInZoomControls(false);&#10;&#10;        mapController = mapView.getController();&#10;        mapController.setZoom(18.0); // Zoom GPS - bem próximo para navegação&#10;&#10;        // Configurar overlay de localização&#10;        locationOverlay = new MyLocationNewOverlay(new GpsMyLocationProvider(this), mapView);&#10;        locationOverlay.enableMyLocation();&#10;        locationOverlay.enableFollowLocation(); // Seguir automaticamente o usuário&#10;        locationOverlay.setDrawAccuracyEnabled(true); // Mostrar círculo de precisão&#10;        mapView.getOverlays().add(locationOverlay);&#10;&#10;        // Localização inicial padrão (será substituída pelo GPS)&#10;        GeoPoint startPoint = new GeoPoint(38.7223, -9.1393); // Lisboa&#10;        mapController.setCenter(startPoint);&#10;    }&#10;&#10;    private void initializeLocationServices() {&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);&#10;&#10;        // Callback para atualizações de localização em tempo real&#10;        locationCallback = new LocationCallback() {&#10;            @Override&#10;            public void onLocationResult(@NonNull LocationResult locationResult) {&#10;                Location location = locationResult.getLastLocation();&#10;                if (location != null) {&#10;                    updateUserLocationOnMap(location);&#10;                }&#10;            }&#10;        };&#10;    }&#10;&#10;    private void updateUserLocationOnMap(Location location) {&#10;        GeoPoint userLocation = new GeoPoint(location.getLatitude(), location.getLongitude());&#10;&#10;        // Atualizar marcador personalizado do usuário&#10;        updateUserMarker(userLocation, location);&#10;&#10;        // Centralizar mapa automaticamente (modo GPS)&#10;        mapController.animateTo(userLocation);&#10;&#10;        // Feedback de precisão para o usuário&#10;        providePrecisionFeedback(location);&#10;&#10;        mapView.invalidate();&#10;    }&#10;&#10;    private void updateUserMarker(GeoPoint location, Location gpsLocation) {&#10;        // Remover marcador anterior&#10;        if (userMarker != null) {&#10;            mapView.getOverlays().remove(userMarker);&#10;        }&#10;&#10;        // Criar marcador atualizado&#10;        userMarker = new Marker(mapView);&#10;        userMarker.setPosition(location);&#10;        userMarker.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM);&#10;        userMarker.setIcon(ContextCompat.getDrawable(this, R.drawable.ic_location_user));&#10;        userMarker.setTitle(&quot; Minha Localização&quot;);&#10;&#10;        // Informações detalhadas do GPS&#10;        String snippet = String.format(&#10;                &quot; Lat: %.6f\n Lon: %.6f\n Precisão: %.1fm\n⚡ Velocidade: %.1f km/h&quot;,&#10;                gpsLocation.getLatitude(),&#10;                gpsLocation.getLongitude(),&#10;                gpsLocation.getAccuracy(),&#10;                gpsLocation.getSpeed() * 3.6 // m/s para km/h&#10;        );&#10;        userMarker.setSnippet(snippet);&#10;&#10;        mapView.getOverlays().add(userMarker);&#10;    }&#10;&#10;    private void providePrecisionFeedback(Location location) {&#10;        float accuracy = location.getAccuracy();&#10;&#10;        // Feedback visual baseado na precisão GPS&#10;        if (accuracy &lt;= 5) {&#10;            // GPS excelente (≤5m) - sem avisos&#10;        } else if (accuracy &lt;= 15) {&#10;            // GPS bom (5-15m) - aviso ocasional&#10;            if (Math.random() &lt; 0.1) { // 10% chance de mostrar&#10;                Toast.makeText(this, &quot;GPS: Boa precisão (&quot; + (int) accuracy + &quot;m)&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;            }&#10;        } else if (accuracy &lt;= 30) {&#10;            // GPS regular (15-30m) - aviso mais frequente&#10;            Toast.makeText(this, &quot;GPS: Precisão moderada (&quot; + (int) accuracy + &quot;m)&quot;,&#10;                    Toast.LENGTH_SHORT).show();&#10;        } else {&#10;            // GPS ruim (&gt;30m) - aviso sempre&#10;            Toast.makeText(this, &quot;⚠️ GPS: Baixa precisão (&quot; + (int) accuracy + &quot;m)&quot;,&#10;                    Toast.LENGTH_LONG).show();&#10;        }&#10;    }&#10;&#10;    private void setupButtonListeners() {&#10;        // Botão &quot;Minha Localização&quot; - centralizar no usuário&#10;        findViewById(R.id.fabMyLocation).setOnClickListener(v -&gt; centerOnUserLocation());&#10;&#10;        // Botão &quot;Ativar Localização&quot; no banner de aviso&#10;        findViewById(R.id.btnEnableLocation).setOnClickListener(v -&gt; {&#10;            if (!checkLocationPermissions()) {&#10;                requestLocationPermissions();&#10;            } else {&#10;                startLocationTracking();&#10;                findViewById(R.id.limitedModeWarning).setVisibility(android.view.View.GONE);&#10;                Toast.makeText(this, &quot;✅ GPS ativado!&quot;, Toast.LENGTH_SHORT).show();&#10;            }&#10;        });&#10;    }&#10;&#10;    public void centerOnUserLocation() {&#10;        if (!checkLocationPermissions()) {&#10;            Toast.makeText(this, &quot; Permissão de localização necessária&quot;, Toast.LENGTH_SHORT).show();&#10;            requestLocationPermissions();&#10;            return;&#10;        }&#10;&#10;        try {&#10;            fusedLocationClient.getLastLocation().addOnSuccessListener(location -&gt; {&#10;                if (location != null) {&#10;                    GeoPoint userLocation = new GeoPoint(location.getLatitude(), location.getLongitude());&#10;                    mapController.animateTo(userLocation);&#10;                    mapController.setZoom(19.0); // Zoom muito próximo&#10;                    Toast.makeText(this, &quot; Centralizado na sua localização&quot;, Toast.LENGTH_SHORT).show();&#10;                } else {&#10;                    Toast.makeText(this, &quot; Aguardando sinal GPS...&quot;, Toast.LENGTH_SHORT).show();&#10;                }&#10;            });&#10;        } catch (SecurityException e) {&#10;            Toast.makeText(this, &quot;❌ Erro ao acessar GPS&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    private void setupObservers() {&#10;        // Observar logout&#10;        authRepository.getLoggedOutLiveData().observe(this, isLoggedOut -&gt; {&#10;            if (Boolean.TRUE.equals(isLoggedOut)) {&#10;                redirectToLogin();&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean checkLocationPermissions() {&#10;        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)&#10;                == PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;               ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)&#10;                == PackageManager.PERMISSION_GRANTED;&#10;    }&#10;&#10;    private void requestLocationPermissions() {&#10;        ActivityCompat.requestPermissions(this,&#10;                new String[]{&#10;                    Manifest.permission.ACCESS_FINE_LOCATION,&#10;                    Manifest.permission.ACCESS_COARSE_LOCATION&#10;                },&#10;                LOCATION_PERMISSION_REQUEST_CODE);&#10;    }&#10;&#10;    private void startLocationTracking() {&#10;        if (!checkLocationPermissions()) {&#10;            return;&#10;        }&#10;&#10;        // Configuração GPS ultra-precisa&#10;        LocationRequest locationRequest = new LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 1000) // Atualiza a cada 1 segundo&#10;                .setWaitForAccurateLocation(true) // Aguarda sinal GPS preciso&#10;                .setMinUpdateIntervalMillis(500) // Mínimo 0.5 segundos entre atualizações&#10;                .setMaxUpdateDelayMillis(2000) // Máximo 2 segundos de atraso&#10;                .setMinUpdateDistanceMeters(1.0f) // Só atualiza se mover pelo menos 1 metro&#10;                .build();&#10;&#10;        try {&#10;            fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, getMainLooper());&#10;&#10;            // Obter última localização conhecida para inicialização rápida&#10;            fusedLocationClient.getLastLocation().addOnSuccessListener(location -&gt; {&#10;                if (location != null &amp;&amp; isLocationAccurate(location)) {&#10;                    updateUserLocationOnMap(location);&#10;                } else {&#10;                    Toast.makeText(this, &quot; Aguardando GPS mais preciso...&quot;, Toast.LENGTH_SHORT).show();&#10;                }&#10;            });&#10;&#10;            Toast.makeText(this, &quot;️ GPS de alta precisão ativado&quot;, Toast.LENGTH_SHORT).show();&#10;        } catch (SecurityException e) {&#10;            Toast.makeText(this, &quot;❌ Erro ao ativar GPS: &quot; + e.getMessage(), Toast.LENGTH_LONG).show();&#10;        }&#10;    }&#10;&#10;    // Novo método para filtrar localizações imprecisas&#10;    private boolean isLocationAccurate(Location location) {&#10;        // Filtros de qualidade GPS&#10;        if (location.getAccuracy() &gt; 20) return false; // Rejeita se precisão &gt; 20 metros&#10;        if (location.getTime() &lt; System.currentTimeMillis() - 30000) return false; // Rejeita se &gt; 30 segundos&#10;        if (location.getSpeed() &gt; 50) return false; // Rejeita velocidades irreais (&gt;180 km/h)&#10;        return true;&#10;    }&#10;&#10;    private void stopLocationTracking() {&#10;        if (fusedLocationClient != null &amp;&amp; locationCallback != null) {&#10;            fusedLocationClient.removeLocationUpdates(locationCallback);&#10;        }&#10;    }&#10;&#10;    private void redirectToLogin() {&#10;        startActivity(new Intent(this, LoginActivity.class));&#10;        finish();&#10;    }&#10;&#10;    @Override&#10;    public boolean onCreateOptionsMenu(Menu menu) {&#10;        getMenuInflater().inflate(R.menu.main_menu, menu);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean onOptionsItemSelected(MenuItem item) {&#10;        if (item.getItemId() == R.id.action_logout) {&#10;            authRepository.signOut();&#10;            return true;&#10;        }&#10;        return super.onOptionsItemSelected(item);&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        // Registrar o receiver para atualizações de localização ao retomar a atividade&#10;        if (checkLocationPermissions()) {&#10;            startLocationTracking();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        // Remover atualizações de localização ao pausar a atividade&#10;        fusedLocationClient.removeLocationUpdates(locationCallback);&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        // Limpar recursos e referências&#10;        mapView.getOverlays().remove(locationOverlay);&#10;        if (userMarker != null) {&#10;            mapView.getOverlays().remove(userMarker);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);&#10;        if (requestCode == LOCATION_PERMISSION_REQUEST_CODE) {&#10;            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {&#10;                // Permissão concedida - iniciar rastreamento de localização&#10;                startLocationTracking();&#10;            } else {&#10;                // Permissão negada - mostrar mensagem apropriada&#10;                Toast.makeText(this, &quot;❌ Permissão de localização necessária para o funcionamento do app&quot;, Toast.LENGTH_LONG).show();&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.msystem.walking;&#10;&#10;import android.Manifest;&#10;import android.content.Intent;&#10;import android.content.pm.PackageManager;&#10;import android.location.Location;&#10;import android.os.Bundle;&#10;import android.preference.PreferenceManager;&#10;import android.view.Menu;&#10;import android.view.MenuItem;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.appcompat.app.AppCompatActivity;&#10;import androidx.core.app.ActivityCompat;&#10;import androidx.core.content.ContextCompat;&#10;&#10;import com.google.android.gms.location.FusedLocationProviderClient;&#10;import com.google.android.gms.location.LocationCallback;&#10;import com.google.android.gms.location.LocationRequest;&#10;import com.google.android.gms.location.LocationResult;&#10;import com.google.android.gms.location.LocationServices;&#10;import com.google.android.gms.location.Priority;&#10;import com.msystem.walking.auth.LoginActivity;&#10;import com.msystem.walking.repository.AuthRepository;&#10;&#10;import org.osmdroid.api.IMapController;&#10;import org.osmdroid.config.Configuration;&#10;import org.osmdroid.tileprovider.tilesource.TileSourceFactory;&#10;import org.osmdroid.util.GeoPoint;&#10;import org.osmdroid.views.MapView;&#10;import org.osmdroid.views.overlay.Marker;&#10;import org.osmdroid.views.overlay.mylocation.GpsMyLocationProvider;&#10;import org.osmdroid.views.overlay.mylocation.MyLocationNewOverlay;&#10;&#10;public class MainActivity extends AppCompatActivity {&#10;    private static final int LOCATION_PERMISSION_REQUEST_CODE = 1001;&#10;&#10;    private AuthRepository authRepository;&#10;    private MapView mapView;&#10;    private IMapController mapController;&#10;    private MyLocationNewOverlay locationOverlay;&#10;    private FusedLocationProviderClient fusedLocationClient;&#10;    private LocationCallback locationCallback;&#10;    private Marker userMarker;&#10;&#10;    @Override&#10;    protected void onCreate(Bundle savedInstanceState) {&#10;        super.onCreate(savedInstanceState);&#10;&#10;        // Configurar OSMDroid para melhor performance&#10;        Configuration.getInstance().load(this, PreferenceManager.getDefaultSharedPreferences(this));&#10;        Configuration.getInstance().setUserAgentValue(getPackageName());&#10;&#10;        setContentView(R.layout.activity_main);&#10;&#10;        authRepository = AuthRepository.getInstance();&#10;&#10;        // Verificar se o usuário está autenticado&#10;        if (authRepository.getCurrentUser() == null) {&#10;            redirectToLogin();&#10;            return;&#10;        }&#10;&#10;        initializeMap();&#10;        initializeLocationServices();&#10;        setupObservers();&#10;        setupButtonListeners();&#10;&#10;        // Verificar e solicitar permissões de localização&#10;        if (checkLocationPermissions()) {&#10;            startLocationTracking();&#10;        } else {&#10;            requestLocationPermissions();&#10;        }&#10;    }&#10;&#10;    private void initializeMap() {&#10;        mapView = findViewById(R.id.osmMapView);&#10;&#10;        // Configurar o mapa com melhor qualidade&#10;        mapView.setTileSource(TileSourceFactory.MAPNIK); // OpenStreetMap padrão&#10;        mapView.setMultiTouchControls(true);&#10;        mapView.setBuiltInZoomControls(false);&#10;&#10;        mapController = mapView.getController();&#10;        mapController.setZoom(18.0); // Zoom GPS - bem próximo para navegação&#10;&#10;        // Configurar overlay de localização&#10;        locationOverlay = new MyLocationNewOverlay(new GpsMyLocationProvider(this), mapView);&#10;        locationOverlay.enableMyLocation();&#10;        locationOverlay.enableFollowLocation(); // Seguir automaticamente o usuário&#10;        locationOverlay.setDrawAccuracyEnabled(true); // Mostrar círculo de precisão&#10;        mapView.getOverlays().add(locationOverlay);&#10;&#10;        // Localização inicial padrão (será substituída pelo GPS)&#10;        GeoPoint startPoint = new GeoPoint(38.7223, -9.1393); // Lisboa&#10;        mapController.setCenter(startPoint);&#10;    }&#10;&#10;    private void initializeLocationServices() {&#10;        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this);&#10;&#10;        // Callback para atualizações de localização em tempo real com filtros de precisão&#10;        locationCallback = new LocationCallback() {&#10;            @Override&#10;            public void onLocationResult(@NonNull LocationResult locationResult) {&#10;                Location location = locationResult.getLastLocation();&#10;                if (location != null &amp;&amp; isLocationAccurate(location)) {&#10;                    updateUserLocationOnMap(location);&#10;                }&#10;                // Se a localização não for precisa o suficiente, simplesmente ignora&#10;            }&#10;        };&#10;    }&#10;&#10;    private void updateUserLocationOnMap(Location location) {&#10;        GeoPoint userLocation = new GeoPoint(location.getLatitude(), location.getLongitude());&#10;&#10;        // Atualizar marcador personalizado do usuário&#10;        updateUserMarker(userLocation, location);&#10;&#10;        // Centralizar mapa automaticamente (modo GPS)&#10;        mapController.animateTo(userLocation);&#10;&#10;        // Feedback de precisão para o usuário&#10;        providePrecisionFeedback(location);&#10;&#10;        mapView.invalidate();&#10;    }&#10;&#10;    private void updateUserMarker(GeoPoint location, Location gpsLocation) {&#10;        // Remover marcador anterior&#10;        if (userMarker != null) {&#10;            mapView.getOverlays().remove(userMarker);&#10;        }&#10;&#10;        // Criar marcador atualizado&#10;        userMarker = new Marker(mapView);&#10;        userMarker.setPosition(location);&#10;        userMarker.setAnchor(Marker.ANCHOR_CENTER, Marker.ANCHOR_BOTTOM);&#10;        userMarker.setIcon(ContextCompat.getDrawable(this, R.drawable.ic_location_user));&#10;        userMarker.setTitle(&quot; Minha Localização&quot;);&#10;&#10;        // Informações detalhadas do GPS&#10;        String snippet = String.format(&#10;                &quot; Lat: %.6f\n Lon: %.6f\n Precisão: %.1fm\n⚡ Velocidade: %.1f km/h&quot;,&#10;                gpsLocation.getLatitude(),&#10;                gpsLocation.getLongitude(),&#10;                gpsLocation.getAccuracy(),&#10;                gpsLocation.getSpeed() * 3.6 // m/s para km/h&#10;        );&#10;        userMarker.setSnippet(snippet);&#10;&#10;        mapView.getOverlays().add(userMarker);&#10;    }&#10;&#10;    private void providePrecisionFeedback(Location location) {&#10;        float accuracy = location.getAccuracy();&#10;&#10;        // Feedback visual baseado na precisão GPS&#10;        if (accuracy &lt;= 5) {&#10;            // GPS excelente (≤5m) - sem avisos&#10;        } else if (accuracy &lt;= 15) {&#10;            // GPS bom (5-15m) - aviso ocasional&#10;            if (Math.random() &lt; 0.1) { // 10% chance de mostrar&#10;                Toast.makeText(this, &quot;GPS: Boa precisão (&quot; + (int) accuracy + &quot;m)&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;            }&#10;        } else if (accuracy &lt;= 30) {&#10;            // GPS regular (15-30m) - aviso mais frequente&#10;            Toast.makeText(this, &quot;GPS: Precisão moderada (&quot; + (int) accuracy + &quot;m)&quot;,&#10;                    Toast.LENGTH_SHORT).show();&#10;        } else {&#10;            // GPS ruim (&gt;30m) - aviso sempre&#10;            Toast.makeText(this, &quot;⚠️ GPS: Baixa precisão (&quot; + (int) accuracy + &quot;m)&quot;,&#10;                    Toast.LENGTH_LONG).show();&#10;        }&#10;    }&#10;&#10;    private void setupButtonListeners() {&#10;        // Botão &quot;Minha Localização&quot; - centralizar no usuário&#10;        findViewById(R.id.fabMyLocation).setOnClickListener(v -&gt; centerOnUserLocation());&#10;&#10;        // Botão &quot;Ativar Localização&quot; no banner de aviso&#10;        findViewById(R.id.btnEnableLocation).setOnClickListener(v -&gt; {&#10;            if (!checkLocationPermissions()) {&#10;                requestLocationPermissions();&#10;            } else {&#10;                startLocationTracking();&#10;                findViewById(R.id.limitedModeWarning).setVisibility(android.view.View.GONE);&#10;                Toast.makeText(this, &quot;✅ GPS ativado!&quot;, Toast.LENGTH_SHORT).show();&#10;            }&#10;        });&#10;    }&#10;&#10;    public void centerOnUserLocation() {&#10;        if (!checkLocationPermissions()) {&#10;            Toast.makeText(this, &quot; Permissão de localização necessária&quot;, Toast.LENGTH_SHORT).show();&#10;            requestLocationPermissions();&#10;            return;&#10;        }&#10;&#10;        try {&#10;            fusedLocationClient.getLastLocation().addOnSuccessListener(location -&gt; {&#10;                if (location != null) {&#10;                    GeoPoint userLocation = new GeoPoint(location.getLatitude(), location.getLongitude());&#10;                    mapController.animateTo(userLocation);&#10;                    mapController.setZoom(19.0); // Zoom muito próximo&#10;                    Toast.makeText(this, &quot; Centralizado na sua localização&quot;, Toast.LENGTH_SHORT).show();&#10;                } else {&#10;                    Toast.makeText(this, &quot; Aguardando sinal GPS...&quot;, Toast.LENGTH_SHORT).show();&#10;                }&#10;            });&#10;        } catch (SecurityException e) {&#10;            Toast.makeText(this, &quot;❌ Erro ao acessar GPS&quot;, Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    private void setupObservers() {&#10;        // Observar logout&#10;        authRepository.getLoggedOutLiveData().observe(this, isLoggedOut -&gt; {&#10;            if (Boolean.TRUE.equals(isLoggedOut)) {&#10;                redirectToLogin();&#10;            }&#10;        });&#10;    }&#10;&#10;    private boolean checkLocationPermissions() {&#10;        return ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)&#10;                == PackageManager.PERMISSION_GRANTED &amp;&amp;&#10;               ContextCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)&#10;                == PackageManager.PERMISSION_GRANTED;&#10;    }&#10;&#10;    private void requestLocationPermissions() {&#10;        ActivityCompat.requestPermissions(this,&#10;                new String[]{&#10;                    Manifest.permission.ACCESS_FINE_LOCATION,&#10;                    Manifest.permission.ACCESS_COARSE_LOCATION&#10;                },&#10;                LOCATION_PERMISSION_REQUEST_CODE);&#10;    }&#10;&#10;    private void startLocationTracking() {&#10;        if (!checkLocationPermissions()) {&#10;            return;&#10;        }&#10;&#10;        // Configuração GPS ultra-precisa&#10;        LocationRequest locationRequest = new LocationRequest.Builder(Priority.PRIORITY_HIGH_ACCURACY, 1000) // Atualiza a cada 1 segundo&#10;                .setWaitForAccurateLocation(true) // Aguarda sinal GPS preciso&#10;                .setMinUpdateIntervalMillis(500) // Mínimo 0.5 segundos entre atualizações&#10;                .setMaxUpdateDelayMillis(2000) // Máximo 2 segundos de atraso&#10;                .setMinUpdateDistanceMeters(1.0f) // Só atualiza se mover pelo menos 1 metro&#10;                .build();&#10;&#10;        try {&#10;            fusedLocationClient.requestLocationUpdates(locationRequest, locationCallback, getMainLooper());&#10;&#10;            // Obter última localização conhecida para inicialização rápida&#10;            fusedLocationClient.getLastLocation().addOnSuccessListener(location -&gt; {&#10;                if (location != null &amp;&amp; isLocationAccurate(location)) {&#10;                    updateUserLocationOnMap(location);&#10;                } else {&#10;                    Toast.makeText(this, &quot; Aguardando GPS mais preciso...&quot;, Toast.LENGTH_SHORT).show();&#10;                }&#10;            });&#10;&#10;            Toast.makeText(this, &quot;️ GPS de alta precisão ativado&quot;, Toast.LENGTH_SHORT).show();&#10;        } catch (SecurityException e) {&#10;            Toast.makeText(this, &quot;❌ Erro ao ativar GPS: &quot; + e.getMessage(), Toast.LENGTH_LONG).show();&#10;        }&#10;    }&#10;&#10;    // Novo método para filtrar localizações imprecisas&#10;    private boolean isLocationAccurate(Location location) {&#10;        // Filtros de qualidade GPS&#10;        if (location.getAccuracy() &gt; 20) return false; // Rejeita se precisão &gt; 20 metros&#10;        if (location.getTime() &lt; System.currentTimeMillis() - 30000) return false; // Rejeita se &gt; 30 segundos&#10;        if (location.getSpeed() &gt; 50) return false; // Rejeita velocidades irreais (&gt;180 km/h)&#10;        return true;&#10;    }&#10;&#10;    private void stopLocationTracking() {&#10;        if (fusedLocationClient != null &amp;&amp; locationCallback != null) {&#10;            fusedLocationClient.removeLocationUpdates(locationCallback);&#10;        }&#10;    }&#10;&#10;    private void redirectToLogin() {&#10;        startActivity(new Intent(this, LoginActivity.class));&#10;        finish();&#10;    }&#10;&#10;    @Override&#10;    public boolean onCreateOptionsMenu(Menu menu) {&#10;        getMenuInflater().inflate(R.menu.main_menu, menu);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    public boolean onOptionsItemSelected(MenuItem item) {&#10;        if (item.getItemId() == R.id.action_logout) {&#10;            authRepository.signOut();&#10;            return true;&#10;        }&#10;        return super.onOptionsItemSelected(item);&#10;    }&#10;&#10;    @Override&#10;    protected void onResume() {&#10;        super.onResume();&#10;        // Registrar o receiver para atualizações de localização ao retomar a atividade&#10;        if (checkLocationPermissions()) {&#10;            startLocationTracking();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected void onPause() {&#10;        super.onPause();&#10;        // Remover atualizações de localização ao pausar a atividade&#10;        fusedLocationClient.removeLocationUpdates(locationCallback);&#10;    }&#10;&#10;    @Override&#10;    protected void onDestroy() {&#10;        super.onDestroy();&#10;        // Limpar recursos e referências&#10;        mapView.getOverlays().remove(locationOverlay);&#10;        if (userMarker != null) {&#10;            mapView.getOverlays().remove(userMarker);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {&#10;        super.onRequestPermissionsResult(requestCode, permissions, grantResults);&#10;        if (requestCode == LOCATION_PERMISSION_REQUEST_CODE) {&#10;            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {&#10;                // Permissão concedida - iniciar rastreamento de localização&#10;                startLocationTracking();&#10;            } else {&#10;                // Permissão negada - mostrar mensagem apropriada&#10;                Toast.makeText(this, &quot;❌ Permissão de localização necessária para o funcionamento do app&quot;, Toast.LENGTH_LONG).show();&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/ic_location_user.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/ic_location_user.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;&#10;    &lt;!-- Ícone de localização principal --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#2196F3&quot;&#10;        android:pathData=&quot;M12,2C8.13,2 5,5.13 5,9c0,5.25 7,13 7,13s7,-7.75 7,-13C19,5.13 15.87,2 12,2zM12,11.5c-1.38,0 -2.5,-1.12 -2.5,-2.5s1.12,-2.5 2.5,-2.5s2.5,1.12 2.5,2.5S13.38,11.5 12,11.5z&quot;/&gt;&#10;&#10;    &lt;!-- Círculo interno do usuário (usando path) --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#4CAF50&quot;&#10;        android:pathData=&quot;M12,7.5 A1.5,1.5 0 1,1 12,10.5 A1.5,1.5 0 1,1 12,7.5 Z&quot;/&gt;&#10;&#10;&lt;/vector&gt;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;24dp&quot;&#10;    android:height=&quot;24dp&quot;&#10;    android:viewportWidth=&quot;24&quot;&#10;    android:viewportHeight=&quot;24&quot;&gt;&#10;&#10;    &lt;!-- Ícone de localização principal --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#2196F3&quot;&#10;        android:pathData=&quot;M12,2C8.13,2 5,5.13 5,9c0,5.25 7,13 7,13s7,-7.75 7,-13C19,5.13 15.87,2 12,2zM12,11.5c-1.38,0 -2.5,-1.12 -2.5,-2.5s1.12,-2.5 2.5,-2.5s2.5,1.12 2.5,2.5S13.38,11.5 12,11.5z&quot;/&gt;&#10;&#10;    &lt;!-- Círculo interno do usuário (usando pathData corrigido) --&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#4CAF50&quot;&#10;        android:pathData=&quot;M12,8.5a1,1 0,1 1,0 2a1,1 0,0 1,0 -2z&quot;/&gt;&#10;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>